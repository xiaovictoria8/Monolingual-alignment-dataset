<!--
	This word alignment interface was written by Chris Callison-Burch.
	It's free and open source.  If publish a paper using data that you collected
	with it, please give me a shout out in the acknowledgements.  You can cite my
	EMNLP-2009 paper "Fast, Cheap, and Creative: Evaluating Translation Quality 
	Using Amazon's Mechanical Turk" or my ACL-2004 paper "Statistical Machine 
        Translation with Word- and Sentence-Aligned Parallel Corpora"
	June 22, 2009
//-->
<h3>Grade Word alignment</h3>

<p>Please approve or reject this word alignment by comparing it to the original Giza alignment. Note: you can make corrections to it too.</p>
<style type="text/css"><!-- 
body,td,div,.p,a{font-family:arial,sans-serif }
div,td{color:#000}
.f,.fl:link{color:#6f6f6f}
a:link,.w,a.w:link,.w a:link{color:#00c}
a:visited,.fl:visited{color:#551a8b}
a:active,.fl:active{color:#f00}
.t a:link,.t a:active,.t a:visited,.t{color:#000}
.t{background-color:#e5ecf9}
.k{background-color:#36c}
.j{width:34em}
.h{color:#36c}
.i,.i:link{color:#a90a08}
.a,.a:link{color:#008000}
.z{display:none}
div.n {margin-top: 1ex}
.n a{font-size:10pt; color:#000}
.n .i{font-size:10pt; font-weight:bold}
.q a:visited,.q a:link,.q a:active,.q {color: #00c; }
.b{font-size: 12pt; color:#00c; font-weight:bold}
.ch{cursor:pointer;cursor:hand}
.e{margin-top: .75em; margin-bottom: .75em}
.g{margin-top: 1em; margin-bottom: 1em}

td.topborder { text-align: center;  background-color: #E2FAFA; border-left: solid 3px #000000; border-right: solid 3px #000000;  border-top: solid 3px #000000;}
td.middleborder { text-align: center; background-color: #E2FAFA; border-left: solid 3px #000000; border-right: solid 3px #000000;  }
td.bottomborder { text-align: center; background-color: #E2FAFA; border-left: solid 3px #000000; border-right: solid 3px #000000; border-bottom: solid 3px #000000; }
 
.blacklink A:link {text-decoration: none; color: black;}
.blacklink A:visited {text-decoration: none; color: black;}
.blacklink A:active {text-decoration: none; color: black;}
.blacklink A:hover {text-decoration: underline; color: black;}
 
td.black { background-color: black; }
td.white { background-color: ghostwhite; }
td.gray  { background-color: gray; }


td.gizaRemoved { background-color: red; }
td.gizaKept { background-color: palegoldenrod; }
td.gizaKeptProb { background-color: mediumspringgreen; }
td.added  { background-color: dodgerblue; }
td.addedProb  { background-color: lightskyblue; }
td.highlight  { background-color: lightpink; }


/* this css class rotates the content inside by 270 degrees */
.vertical-box {
     -moz-transform: rotate(270deg);  /* FF3.5+ */
       -o-transform: rotate(270deg);  /* Opera 10.5 */
  -webkit-transform: rotate(270deg);  /* Saf3.1+, Chrome */
             filter:  progid:DXImageTransform.Microsoft.BasicImage(rotation=1.5);  /* IE6,IE7 */
         -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1.5)"; /* IE8 */
		 cursor:pointer;
		 position:absolute;
}
//-->
</style>
<center><script type="text/Javascript"> 
	// the URL directory where rotated word images are stored
	var imageDirectory = "http://cs.jhu.edu/~ccb/images/";
 
	// specify whether the languages should be written right-to-left
	var sourceIsRTL = false;
	var targetIsRTL = false;
 
	// indicates whether to switch the view from the source being 
	// along top (default) or the target on top (transposed).
	// The results still keep the same source / target names.
	var viewTransposed =  false;
 

	// read in the values for this sentence pair
 
	// ${source} and ${target} should contain whitespace delimited words
	var sourceString = "${source}";

	var targetString = "${target}";

	// sure alignments should have the format "0-0 0-1 1-2" where the first number 
	// in each pair is the index of the source word, and the second it the target
	var turkerPossAlignments = "${possAlignments}";
 
	// indicates which rows and columns are highlighted 
	var turkerSourceHighlights = "${sourceHighlights}";
	var turkerTargetHighlights = "${targetHighlights}";
 
	// ccb - might want to make this more general so that includes any changes instead of just change to the Giza++ sure alignments.
	var gizaAlignments =  "${gizaAlignments}";

	var turkerSureAlignments = "${sureAlignments}";
 	if (turkerSureAlignments == "unchanged") {
		turkerSureAlignments = gizaAlignments
	}
 
	// begin example values
	// var sourceString = "he believes that canada and china will be able to become very good cooperating partners .";
	// var targetString = "he is certain that canada and china can be cooperative partners .";
	// var turkerSureAlignments = "0-0 1-1 1-2 2-3 3-4 4-5 5-6 6-7 6-8 7-7 7-8 8-7 8-8 9-7 9-8 10-7 10-8 13-9 14-10 15-11";
	// var turkerPossAlignments = "";
	// var turkerSourceHighlights = "11 12";
	// var turkerTargetHighlights = "";
	// var gizaAlignments =  "0-0 1-2 2-3 3-4 4-5 5-6 6-7 7-8 8-7 9-7 10-8 11-9 12-9 13-9 14-10 15-11";
	// end example values


	if(viewTransposed) {
		var tmp = sourceString;
		sourceString = targetString;
		targetString = tmp;
		tmp = turkerSourceHighlights;
		turkerSourceHighlights = turkerTargetHighlights;
		turkerTargetHighlights = tmp;
		tmp = sourceIsRTL;
		sourceIsRTL = targetIsRTL;
		targetIsRTL = tmp;
 
		turkerSureAlignments = transposeAlignments(turkerSureAlignments);
		turkerPossAlignments = transposeAlignments(turkerPossAlignments);
		gizaAlignments = transposeAlignments(gizaAlignments);
	}
 
 
	// split the source and target sentences into words
	var whitespacePattern = /\s/;
	var sourceWords = sourceString.split(whitespacePattern);
	var targetWords = targetString.split(whitespacePattern);
 
	var width = sourceWords.length;
	var height = targetWords.length;
	
	// initialize the sureGrid and the probGrid
	var sureGrid = initializeBooleanGrid(width, height, turkerSureAlignments);
	var probGrid = initializeBooleanGrid(width, height, turkerPossAlignments);

	var gizaGrid = initializeBooleanGrid(width, height, gizaAlignments);
 
 
	// initialize the highlighted rows and columns
	var sourceHighlights = initializeBooleanArray(width, turkerSourceHighlights);
	var targetHighlights =  initializeBooleanArray(height, turkerTargetHighlights);
 
	if(sourceIsRTL) {
		writeHtmlAlignmentTableRTL(sourceWords, targetWords, sureGrid, probGrid, gizaGrid,  sourceHighlights, targetHighlights, imageDirectory);
	} else {
		writeHtmlAlignmentTable(sourceWords, targetWords, sureGrid, probGrid, gizaGrid, sourceHighlights, targetHighlights, imageDirectory);
	}
 
 
 
	
	// log the time...
	date = new Date();
	timeAtStart = date.getTime();
	timeOfLastModification = date.getTime();
	activeTime = 0;
 
	// Transposes the string form of the alignment.  Changes each x-y into y-x
	function transposeAlignments(alignmentString) {
		var transposedAlignmentsString = "";
		var whitespacePattern = /\s/;
		var dash = '-';
		var points = alignmentString.split(whitespacePattern);
		for(i = 0; i < points.length; i++) {
			if(points[i].indexOf(dash) > 0) {
				var point = points[i].split(dash);
				var x = point[0];
				var y = point[1];
				var transposedAlignmentsString = transposedAlignmentsString + y + "-" + x + " ";
			}
		}	
		transposedAlignmentsString.replace(/\s$/, '');
		return transposedAlignmentsString;
	}
  
	// Returns an initialized boolean grid.  Sets the points to true
	// that are included in the alignmentString as "x-y".
	function initializeBooleanGrid(width, height, alignmentString) {
		var grid = new Array(width);
		for (i = 0; i < grid.length; i++) {
			grid[i] = new Array(height);
			for(j = 0; j < height; j++) {
				grid[i][j] = false;
			}
		}
		// Set the points in alignmentString to true
		var whitespacePattern = /\s/;
		var dash = '-';
		var points = alignmentString.split(whitespacePattern);
		for(i = 0; i < points.length; i++) {
			if(points[i].indexOf(dash) > 0) {
				var point = points[i].split(dash);
				var x = point[0];
				var y = point[1];
				grid[x][y] = true;
			}
		}	
		return grid;
	}
 
 
 
 
	// Returns an initialized boolean array
	function initializeBooleanArray(length, indexOfTruesString) {
		// pad the indexOfTruesString with spaces
		indexOfTruesString = " " + indexOfTruesString + " ";
		var array = new Array(length);
		for (i = 0; i < array.length; i++) {
			array[i] = false;
		}
 
		// set the points in alignmentString to true
		var whitespacePattern = /\s/;
		var indicies = indexOfTruesString.split(whitespacePattern);
		for(i = 0; i < indicies.length; i++) {
			var index = indicies[i];
			array[index] = true;
		}	
		return array;
	}
 
	// This method outputs the HTML table with clickable grid squares 
	// that are indexed into the sure and prob alignment boolean grids.
	// There is an alternate version for source languages that should be
	// displayed right-to-left.
	function writeHtmlAlignmentTable(sourceWords, targetWords, sureGrid, probGrid, gizaGrid, 
					 highlightedSourceWords, highlightedTargetWords, imageDirectory) {
		var smallerFont = false;
		var size = 20;
		var fontSize = 0;
		if(sourceWords.length > 20 || targetWords.length > 20) {
			size = 15;
			smallerFont = true;
			fontSize = -1;
		}
			
		document.write('<table>\n');
 
		for(row = 0; row < targetWords.length; row++) {
			// print the target word
			document.write('<tr>\n');	
			var targetWord = targetWords[row];
			if(!targetIsRTL) {
				document.write('<td>');	
			} else {
				document.write('<td dir="rtl">');	
			}
			if(smallerFont) { 
				document.write('<font size=' + fontSize + '>');
			}
			document.write('<span class="blacklink"><a href="javascript:clickRow(' + row + ')">');
			document.write(targetWord);
			document.write('<a href="javascript:clickRow(' + row + ')"></span>');
			if(smallerFont) document.write('</font>');
			document.write('</td>\n\t');
			// print this row
			for(column = 0; column < sourceWords.length; column++) {
				if(gizaGrid[column][row]) {
					// colorize the items that overlapped with the Giza++ alignments
					if(sureGrid[column][row]) {
						document.write('<td class="gizaKept" id="button.' + column + '.' + row + '">');
					} else if(probGrid[column][row]) {
						document.write('<td class="gizaKeptProb" id="button.' + column + '.' + row + '">');
					} else {
						document.write('<td class="gizaRemoved" id="button.' + column + '.' + row + '">');
					}
				} else if(sureGrid[column][row]) {
					// not in the giza
					document.write('<td class="added" id="button.' + column + '.' + row + '">');
				} else if(probGrid[column][row]) {
					document.write('<td class="addedProb" id="button.' + column + '.' + row + '">');
				} else {
					if(highlightedSourceWords[column] || highlightedTargetWords[row]) {
						document.write('<td class="highlight" id="button.' + column + '.' + row + '">');
					} else {
						document.write('<td class="white" id="button.' + column + '.' + row + '">');
					}
				}
				document.write('<a href="javascript:clickButton(' + column + ',' + row + ')">');
				document.write('<img src= "'+ imageDirectory + 'clearpixel.gif" border="0" ');
				document.write('title="' + targetWords[row] + ', ' + sourceWords[column]+ '" ');
				document.write('width="' + size + '" height="' + size + '"></a>');
				document.write('</td>\n');	
			}
			
			// print the target word again
			if(!targetIsRTL) {
				document.write('<td>');	
			} else {
				document.write('<td dir="rtl">');	
			}
			if(smallerFont) document.write('<font size=' + fontSize + '>');
			document.write('<span class="blacklink"><a href="javascript:clickRow(' + row + ')">');
			document.write(targetWord);
			document.write('<a href="javascript:clickRow(' + row + ')"></span>');
			if(smallerFont) document.write('</font>');
			document.write('</td>\n\t');
			
			document.write('</tr>');	
			document.write('\n');
		}
		
		document.write('</table>\n')
		
		// print the source words as a table header
		document.write('<div id="head-cells">\n');
		
		// write the source words in divs for the header
		for(i = 0; i < sourceWords.length; i++) {
			var word = sourceWords[i];
			document.write('\t<div class="vertical-box" onMouseUp="clickColumn(' + i + ');">');
			document.writeln(word);
			document.write('</div>\n');

		}
		document.write('</div>\n');
		
		// write the source in divs for the footer
		document.write('<div id="foot-cells">\n');
		for(i = 0; i < sourceWords.length; i++) {
			var word = sourceWords[i];
			document.write('\t<div class="vertical-box" onMouseUp="clickColumn(' + i + ');">');
			document.write(word);
			document.write('</div>\n');
		}
		document.write('</div>\n');
		
		var table = document.getElementsByTagName("table").item(0);
		var firstRow = table.getElementsByTagName("tr").item(0).getElementsByTagName("td");
		var cellTopPosition = getY(document.getElementsByTagName("table").item(0));
		var cellBottomPosition = cellTopPosition + table.offsetHeight;
		var cellCenterPositions = new Array();
		var headCells = document.getElementById("head-cells").getElementsByTagName("div");
		var footCells = document.getElementById("foot-cells").getElementsByTagName("div");
		var tableVerticalMargin = getLongestWord(headCells);

		// setting the top and bottom margin of the table -- needed to ensure the space for the head and foot words is empty
		table.style.marginTop = (tableVerticalMargin + firstRow[1].offsetHeight) + "px";
		table.style.marginBottom = (tableVerticalMargin + firstRow[1].offsetHeight) + "px";
		
		// calculating the center positions of all cells
		for(i = 1; i < firstRow.length - 1; i++) {
			cellCenterPositions.push(getX(firstRow[i]) + (firstRow[i].offsetWidth / 2));
		}
	
		// placing head words over the top cells
		for (i = 0; i < headCells.length; i++) {
			headCells[i].style.top = (cellTopPosition - (headCells[i].offsetWidth / 2) - (firstRow[1].offsetHeight / 2) + tableVerticalMargin) + "px";
			headCells[i].style.left = (cellCenterPositions[i] - (headCells[i].offsetWidth / 2)) + "px";
		}
		
		//placing the footer words bellow the bottom cells
		for (i = 0; i < footCells.length; i++) {
			footCells[i].style.top = (cellBottomPosition + (headCells[i].offsetWidth / 2) + (firstRow[1].offsetHeight / 4)  + tableVerticalMargin) + "px";
			footCells[i].style.left = (cellCenterPositions[i] - (footCells[i].offsetWidth / 2)) + "px";
		}

		
	}
 
 
	// An alternate version of writeHtmlAlignmentTable which displays the
	// source language in a right to left (RTL) fashion. 
	function writeHtmlAlignmentTableRTL(sourceWords, targetWords, sureGrid, probGrid, gizaGrid,
					 highlightedSourceWords, highlightedTargetWords, imageDirectory) {
		var smallerFont = false;
		var size = 15;
		var fontSize = 0;
		if(sourceWords.length > 20 || targetWords.length > 20) {
			size = 11;
			smallerFont = true;
			fontSize = -1;
		}
			
		document.write('<table>\n');
 
		for(row = 0; row < targetWords.length; row++) {
			// print the target word
			document.write('<tr>\n');	
			var targetWord = targetWords[row];
			document.write('<td>');	
			if(smallerFont) { 
				document.write('<font size=' + fontSize + '>');
			}
			document.write('<span class="blacklink"><a href="javascript:clickRow(' + row + ')">');
			document.write(targetWord);
			document.write('<a href="javascript:clickRow(' + row + ')"></span>');
			if(smallerFont) document.write('</font>');
			document.write('</td>\n\t');
			// print this row
			for(column = sourceWords.length-1; column >= 0; column--) {
				if(gizaGrid[column][row]) {
					// colorize the items that overlapped with the Giza++ alignments
					if(sureGrid[column][row]) {
						document.write('<td class="gizaKept" id="button.' + column + '.' + row + '">');
					} else if(probGrid[column][row]) {
						document.write('<td class="gizaKeptProb" id="button.' + column + '.' + row + '">');
					} else {
						document.write('<td class="gizaRemoved" id="button.' + column + '.' + row + '">');
					}
				} else if(sureGrid[column][row]) {
					// not in the giza
					document.write('<td class="added" id="button.' + column + '.' + row + '">');
				} else if(probGrid[column][row]) {
					document.write('<td class="addedProb" id="button.' + column + '.' + row + '">');
				} else {
					if(highlightedSourceWords[column] || highlightedTargetWords[row]) {
						document.write('<td class="highlight" id="button.' + column + '.' + row + '">');
					} else {
						document.write('<td class="white" id="button.' + column + '.' + row + '">');
					}
				}
				document.write('<a href="javascript:clickButton(' + column + ',' + row + ')">');
				document.write('<img src= "'+ imageDirectory + 'clearpixel.gif" border="0" ');
				document.write('title="' + targetWords[row] + ', ' + sourceWords[column]+ '" ');
				document.write('width="' + size + '" height="' + size + '"></a>');
				document.write('</td>\n');	
			}
			
			// print the target word again
			document.write('<td>');	
			if(smallerFont) document.write('<font size=' + fontSize + '>');
			document.write('<span class="blacklink"><a href="javascript:clickRow(' + row + ')">');
			document.write(targetWord);
			document.write('<a href="javascript:clickRow(' + row + ')"></span>');
			if(smallerFont) document.write('</font>');
			document.write('</td>\n\t');
			
			document.write('</tr>');	
			document.write('\n');
		}
		
		document.write('</table>\n');
		
		// print the source words as a table header
		document.write('\t<div id="head-cells">\n');
		
		for(i = sourceWords.length-1; i >= 0; i--) {
			var word = sourceWords[i];
			document.write('\t<div class="vertical-box" onMouseUp="clickColumn(' + i + ')">');
			document.write(word);
			document.write('</div>\n');
		}
		document.write('\t</div>\n');
		
		// print the source words as a table footer
		document.write('\t<div id="foot-cells">\n');
		
		for(i = sourceWords.length-1; i >= 0; i--) {
			var word = sourceWords[i];
			document.write('\t<div class="vertical-box" onMouseUp="clickColumn(' + i + ')">');
			document.write(word);
			document.write('</div>\n');
		}
		document.write('</div>\n');
		
		var table = document.getElementsByTagName("table").item(0);
		var firstRow = table.getElementsByTagName("tr").item(0).getElementsByTagName("td");
		var cellTopPosition = getY(document.getElementsByTagName("table").item(0));
		var cellBottomPosition = cellTopPosition + table.offsetHeight;
		var cellCenterPositions = new Array();
		var headCells = document.getElementById("head-cells").getElementsByTagName("div");
		var footCells = document.getElementById("foot-cells").getElementsByTagName("div");
		var tableVerticalMargin = getLongestWord(headCells);

		// setting the top and bottom margin of the table -- needed to ensure the space for the head and foot words is empty
		table.style.marginTop = (tableVerticalMargin + firstRow[1].offsetHeight) + "px";
		table.style.marginBottom = (tableVerticalMargin + firstRow[1].offsetHeight) + "px";
		
		// calculating the center positions of all cells
		for(i = 1; i < firstRow.length - 1; i++) {
			cellCenterPositions.push(getX(firstRow[i]) + (firstRow[i].offsetWidth / 2));
		}
	
		// placing head words over the top cells
		for (i = 0; i < headCells.length; i++) {
			headCells[i].style.top = (cellTopPosition - (headCells[i].offsetWidth / 2) - (firstRow[1].offsetHeight / 2) + tableVerticalMargin) + "px";
			headCells[i].style.left = (cellCenterPositions[i] - (headCells[i].offsetWidth / 2)) + "px";
		}
		
		//placing the footer words bellow the bottom cells
		for (i = 0; i < footCells.length; i++) {
			footCells[i].style.top = (cellBottomPosition + (headCells[i].offsetWidth / 2) + (firstRow[1].offsetHeight / 4)  + tableVerticalMargin) + "px";
			footCells[i].style.left = (cellCenterPositions[i] - (footCells[i].offsetWidth / 2)) + "px";
		}
	}
	
	// returns the X absolute position of the element
	function getX( oElement ){
		var iReturnValue = 0;
		while( oElement != null ) {
			iReturnValue += oElement.offsetLeft;
			oElement = oElement.offsetParent;
		}
		return iReturnValue;
	}
	
	// returns the Y absolute position if the element
	function getY( oElement ){
		var iReturnValue = 0;
		while( oElement != null ) {
			iReturnValue += oElement.offsetTop;
			oElement = oElement.offsetParent;
		}
		return iReturnValue;
	}
	
	// calculated the longest word
	function getLongestWord (words) {
		var top = 0;
		for (var i = 0; i < words.length; i++) {
			if (top < words[i].offsetWidth) {
				top = words[i].offsetWidth;
			}
		}
		return top;
	}
 
 
 
	// Writes the path to the image of a word.  Expects an image server like
	// http://ironman.jhu.edu/wordImageServer/getImage?word=pureba&rotate=-90
	// We use images because rotated text is not supported in cross-platform HTML.
	function getImagePath(word, imageDirectory) {
		return imageDirectory + "getImage?word=" + word + "&rotate=-90";
	}
 
	
	function clickButton(x, y) { 
		updateTime();
		var button = document.getElementById("button."+x+"."+y);
		if(sureGrid[x][y] == false && probGrid[x][y] == false) {
			sureGrid[x][y] = true;	
			probGrid[x][y] = false;
	
			if(gizaGrid[x][y]) {
				button.className = "gizaKept";
			} else {
				button.className = "added";
			}
		} else {
			if(probGrid[x][y] == false) {
				sureGrid[x][y] = false;
				probGrid[x][y] = true;

				if(gizaGrid[x][y]) {
					button.className = "gizaKeptProb";
				} else {
					button.className = "addedProb";
				}

			} else {
				sureGrid[x][y] = false;
				probGrid[x][y] = false;	
				if(sourceHighlights[x] || targetHighlights[y]) {
					if(gizaGrid[x][y]) {
						button.className = "gizaRemoved";
					} else {
						button.className = "highlight";
					}
				} else {
					if(gizaGrid[x][y]) {
						button.className = "gizaRemoved";
					} else {
						button.className = "white";
					}
				}
			}
		}
		document.mturk_form.sureAlignments.value = boolGridToString(sureGrid);
		document.mturk_form.possAlignments.value = boolGridToString(probGrid);
	}
	
	
	
	function clickRow(y) { 
		updateTime();
		targetHighlights[y] = (!targetHighlights[y]);
		var x = 0;
		for(x = 0; x < width; x++) {
			var button = document.getElementById("button."+x+"."+y);
			if(sureGrid[x][y] == false && probGrid[x][y] == false && gizaGrid[x][y] == false) {
				if(sourceHighlights[x] || targetHighlights[y]) {

					button.className = "highlight";
				} else {	
					button.className = "white";
				}
			} 
		}

		
		if(!viewTransposed) {
			document.mturk_form.targetHighlights.value = highlightsToString(targetHighlights);
			document.mturk_form.sourceHighlights.value = highlightsToString(sourceHighlights);
		} else {
			document.mturk_form.targetHighlights.value = highlightsToString(sourceHighlights);
			document.mturk_form.sourceHighlights.value = highlightsToString(targetHighlights);
		}
	}
	
	function clickColumn(x) { 
		updateTime();
		sourceHighlights[x] = (!sourceHighlights[x]);
		var y = 0;
		for(y = 0; y < height; y++) {
			var button = document.getElementById("button."+x+"."+y);
			if(sureGrid[x][y] == false && probGrid[x][y] == false && gizaGrid[x][y] == false) {
				if(sourceHighlights[x] || targetHighlights[y]) {
					button.className = "highlight";
				} else {	
					button.className = "white";
				}
			} 
		}
		if(!viewTransposed) {
			document.mturk_form.targetHighlights.value = highlightsToString(targetHighlights);
			document.mturk_form.sourceHighlights.value = highlightsToString(sourceHighlights);
		} else {
			document.mturk_form.targetHighlights.value = highlightsToString(sourceHighlights);
			document.mturk_form.sourceHighlights.value = highlightsToString(targetHighlights);
		}
	}
	
	
	function boolGridToString(grid) {
		var gridString = "";
		for(i = 0; i < grid.length; i++) {
			row = grid[i];
			for(j = 0; j < row.length; j++) {
				if(grid[i][j]) {
					gridString += i + "-" + j + " ";
				}
			}
		}
		// remove the training space
		gridString = gridString.substring(0, gridString.length-1);
 
		if(viewTransposed) {
			gridString = transposeAlignments(gridString);
		}
		return gridString;
	}
	
	// Converts an array of highlights into a string
	function highlightsToString(array) {
		var arrayString = "";
		for(i = 0; i < array.length; i++) {
			if(array[i]) {
				arrayString += i + " ";
			}
		}
		// remove the training space
		arrayString = arrayString.substring(0, arrayString.length-1);
		return arrayString;
	}
	
	// Updates the activeTime and timeOfLastModification
	function updateTime() {
		var date = new Date();
		var currTime = date.getTime();
		var timeElapse = currTime - timeOfLastModification;
		timeOfLastModification = currTime;
		
		// only increment the active time if the time since 
		// the last modification is less than 5 minutes...
		if(timeElapse < 300000) {
			activeTime += timeElapse;
		}
		document.mturk_form.startTime.value = timeAtStart;
		document.mturk_form.endTime.value = timeOfLastModification;
		document.mturk_form.activeTime.value = activeTime;
	}
</script></center>

<center>
<h3>Worker ID: ${WorkerId}</h3>

<h3>HIT ID: ${HITId}</h3>
<label for="accept"><font size="+2">Accept</font></label> <input id="accept" name="judgment" type="radio" value="accept" /> <label for="reject"><font size="+2">Reject</font></label> <input id="reject" name="judgment" type="radio" value="reject" /> <label for="skip"><font size="+2">Don&#39;t Know</font></label> <input id="skip" name="judgment" type="radio" value="skip" /><br />
<input name="submit" type="submit" value="Submit" /></center>

<p>Here is a key to the colors:</p>

<table>
	<tbody>
		<tr>
			<td>Giza alignment was removed</td>
			<td class="gizaRemoved"><img boarder="0" height="25" src="http://cs.jhu.edu/~ccb/images/clearpixel.gif" width="25" /></td>
		</tr>
		<tr>
			<td>Giza alignment was kept</td>
			<td class="gizaKept"><img boarder="0" height="25" src="http://cs.jhu.edu/~ccb/images/clearpixel.gif" width="25" /></td>
		</tr>
		<tr>
			<td>Giza changed to probable</td>
			<td class="gizaKeptProb"><img boarder="0" height="25" src="http://cs.jhu.edu/~ccb/images/clearpixel.gif" width="25" /></td>
		</tr>
		<tr>
			<td>New sure alignment inserted</td>
			<td class="added"><img boarder="0" height="25" src="http://cs.jhu.edu/~ccb/images/clearpixel.gif" width="25" /></td>
		</tr>
		<tr>
			<td>New prob alignment inserted</td>
			<td class="addedProb"><img boarder="0" height="25" src="http://cs.jhu.edu/~ccb/images/clearpixel.gif" width="25" /></td>
		</tr>
		<tr>
			<td>Row/column was highlighted</td>
			<td class="highlight"><img boarder="0" height="25" src="http://cs.jhu.edu/~ccb/images/clearpixel.gif" width="25" /></td>
		</tr>
	</tbody>
</table>

<form action="edit" method="get" name="mturk_form"><input name="sureAlignments" type="hidden" value="unchanged" /> <input name="possAlignments" type="hidden" value="unchanged" /> <input name="sourceHighlights" type="hidden" value="unchanged" /> <input name="targetHighlights" type="hidden" value="unchanged" /> <input name="startTime" type="hidden" value="" /> <input name="endTime" type="hidden" value="" /> <input name="activeTime" type="hidden" value="" /></form>
